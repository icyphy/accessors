<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="renderHTML.xsl"?>
<!DOCTYPE class PUBLIC "-//TerraSwarm//DTD Accessor 1//EN"
    "http://www.terraswarm.org/accessors/Accessor_1.dtd">
<class name="WebSocketServer" extends="org.terraswarm.JSAccessor">
  <version>0.1 $Date$</version>
  <author>Hokeun Kim and Edward A. Lee</author>
  <input
    name="hostInterface"
    value="localhost"
    type="string"
    description="The IP address or domain name of the network interface to listen for connections on."/>
  <input
    name="port"
    value="8080"
    type="number"
    description="The port to listen for connections on."/>
  <input
    name="toSend"
    value=""
    type="JSON"
    description="The data to be sent on one or more open sockets. If this is a JSON object with 'socketID' field and a 'message' field, then send the value of the message field to the socket identified by the socketID field. If the input has any other form, then the message is broadcast to all open socket connections."/>
  <output
    name="received"
    type="JSON"
    description="A message received a client in the form of a JSON object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client."/>
  <output
    name="connection"
    type="JSON"
    description="An output produced when a new socket connection request has come in and the connection has been established and when that connection is closed. The output is a JSON object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'status' field, which is the string 'open' or 'closed'."/>
  <require name="webSocket"/>   
  <description type="text/html">
    <![CDATA[
This accessor starts a server that listens for web socket connection requests on the specified
hostInterface and port.  The hostInterface is needed only if the host machine has more than one
network interface (e.g. Ethernet and WiFi) and 'localhost' does not resolve to the desired interface.
When a connection request comes in, the connection is established, and a <i>connection</i> output
is produced.  When a message arrives on such a connection, a <i>received</i> output is produced.
When an input arrives on <i>toSend</i>, then a message is sent to one or all of the open socket connections.
When wrapup() is invoked, this accessor closes the server and all connections.
The messages can be any type that has a JSON representation.
For incomming messages, this accessor assumes that the message is
a string in UTF-8 that encodes a JSON object.
  ]]>
  </description>
  <script type="text/javascript">
    // <![CDATA[
  var WebSocket = require('webSocket');
    
  var server = null;
  var socketID = 0;

  exports.initialize = function() {
    if (!server) {
      server = new WebSocket.Server({'port':get('port')});
      server.on('listening', onListening);
      server.on('connection', onConnection);
      server.start();
    }
    socketID = 0;
  }

  function onListening() {
    console.log('Server: Listening for socket connection requests.');
  }
  
  function onConnection(socket) {
    var id = socketID++;
    console.log('Server: new socket established with ID: ' + id);
    send({'socketID':id, 'status':'open'}, 'connection');
    socket.on('message', function(message) {
      send({'socketID':id, 'message':message}, 'received');
    });
    // For each new connection, add an input handler.
    var handler = addInputHandler(function() {
      var data = get('toSend');
      if (data) {
        if (data.socketID && data.message) {
          // data has the right form for a point-to-point send.
          if (data.socketID == id) {
            // id matches this socket.
            console.log("Sending to socket id " + id + " message: " + data.message);
            socket.send(data.message);
          }
        } else {
          // No socketID or message, so this is a broadcast message.
          console.log("Broadcasting to socket id " + id + " message: " + data);
          socket.send(data);
        }
      }
    }, 'toSend');
    
    socket.on('close', function(message) {
      send({'socketID':id, 'status':'closed'}, 'connection');
      removeInputHandler(handler, 'toSend');
    });
  }
  
  function wrapup() {
    if (server != null) {
      server.close();
      server = null;
    }
  }
    // ]]>
  </script>
</class>
